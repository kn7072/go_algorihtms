package main

import (
	"fmt"
	"runtime"
)

//https://habr.com/ru/post/489862/
func main() {

    // NumCPU returns the number of logical
    // CPUs usable by the current process.
    fmt.Println(runtime.NumCPU()) // это P - processor GOMAXPROC
	// Каждому P назначается поток ОС (M)

	/*
		G - горутина
		M - machine - тред (поток) ОС(обертки над тредами ОС)
		P - processor - то, что выполняет наш Go-код

	Требования к планировщику.  https://goimposter.blog/2021/09/10/%D0%BF%D0%BB%D0%B0%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D1%89%D0%B8%D0%BA-%D0%B2-go/

	При создании планировщика, разработчики языка Go ставили перед собой следующие требования:
		Горутины должны быть легковесными, в идеале хорошо иметь возможность запустить 1 млн горутин на процесс.
		Горутины можно только создавать, нельзя настраивать (задавать приоритет, размер стека и т.д.).
		Горутины должны выполняться параллельно.
		Иметь возможность масштабирования, то есть возможность увеличивать количество выполняемых горутин пропорционально увеличению количества ядер.
		Операции ввода\вывода, системные вызовы, вызовы кода на языке C (cgo) должны обрабатываться эффективно.
		Горутины должны планироваться честно: если горутину поставили на выполнение, она должна выполниться в обозримом будущем.
		У горутины должен быть бесконечный стек. Это 1 ГБ для 64-разрядных систем и 250 МБ для 32-разрядных.

	Есть глобальная очередь горутин, защищенная мьютексом. Пара примеров её использования:
    	если процессор создал горутину на выполнение, а его локальная очередь переполнена, то часть горутин из локальной очереди передаётся в глобальную.
    	у процессора закончились  горутины в локальной очереди, тогда он забирает часть горутин на выполнение из глобальной очереди.

	За заблокированными горутинами планировщик может не следить, 
	так как они помещаются в очереди объектов блокировки: каналов, мьютексов, таймеров, объектов, работающих с сетевым вводом\выводом. 
	

	Вспомним порядок выбора горутины на исполнение: 
		локальная очередь.
		глобальная очередь.
		network poller.

	Если в локальных очередях процессоров всегда есть горутины на выполнение, то планировщик может не добираться до горутин из глобальной очередь и network poller.

	Эта несправедливость решается так:
	    каждый 61 раз глобальная очередь проверяется вперед локальной.
    	для горутин из network poller есть отдельный тред, который иногда проверяет есть ли в network poller горутины, готовые к выполнению.

	*/
}