package main

import (
	"fmt"
	"time"
	"sync"
)
// https://ubiklab.net/posts/race-condition-and-data-race/
/*
Существует много формулировок определения:

    Race condition представляет собой класс проблем, в которых корректное поведение системы зависит от двух независимых событий, происходящих в правильном порядке, однако отсутствует механизм, для того чтобы гарантировать фактическое возникновение этих событий.

    Race condition — ошибка проектирования многопоточной системы или приложения, при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

    Race condition — это нежелательная ситуация, которая возникает, когда устройство или система пытается выполнить две или более операций одновременно, но из-за природы устройства или системы, операции должны выполняться в правильной последовательности, чтобы быть выполненными правильно.

    Race condition — это недостаток, связанный с синхронизацией или упорядочением событий, что приводит к ошибочному поведению программы.

Но мне нравиться наиболее короткое и простое:

    Race condition — это недостаток, возникающий, когда время или порядок событий влияют на правильность программы.

Важно, что Race condition — это семантическая ошибка.

*/

func main() {
	go func() {
		fmt.Printf("A->")
	 }()
	 
	 go func() {
		fmt.Printf("B")
	 }()
	// если много раз запускать можно получить разные результаты - порядок сообщений

	/*
		Учитывая, что race condition семантическая ошибка, нет общего способа который может отличить правильное и неправильное поведение программы в общем случае.
	*/

	/*
	еще один пример
	В результате на консоле получим четные и нечетные числа, а расчитывали увидеть только четные.
    */
	x := 0
	for i := 0; i < 20; i++ {
		go func() {
			x++
		}()
		
		go func() {
			if x%2 == 0 {
				time.Sleep(1 * time.Millisecond)
				fmt.Println(x)
			}
		}()
	}
	time.Sleep(time.Second * 3)

	/*
		Проблемы с доступом к общим ресурсам проще обнаружить автоматически и решаются они обычно с помощью синхронизации:
	*/
	var mu sync.Mutex
	x = 0
	for i := 0; i < 20; i++ {
		go func() {
			mu.Lock()
			x++
			mu.Unlock()
		}()
		go func() {
			mu.Lock()
			if x%2 == 0 {
				time.Sleep(1 * time.Millisecond)
				fmt.Println("mutex", x)
			}
			mu.Unlock()
		}()
	}
	time.Sleep(time.Second * 3)
}